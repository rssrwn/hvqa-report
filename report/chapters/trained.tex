\documentclass[../report.tex]{subfiles}


\begin{document}


\chapter{Trained Model}
\label{chapter:trained}


In contrast to the hardcoded model, the trained H-PERL model does not use manually engineered relations or events components, and must therefore rely on using components which can be trained. The trained model also uses the QA-data version of the OceanQA dataset, rather than the full-data version which the hardcoded model was able to use to train its properties component. This means that the trained model needs to rely on the data contained in QA pairs alone to train its components.

The model is trained using \textit{curriculum learning} - the model learns concepts incrementally. In the case of H-PERL, this means that the model is, firstly, trained to understand object properties, then trained to understand relations, and, finally, is trained to understand events. After training a component, the component is used to extract its corresponding symbolic information from the training data, which can then be used by the next component to be trained.

% The three trained core components of the model are outlined in this chapter. After training each component, the component is used to extract relevant symbolic information from the training data before the next component in the architecture is trained.

% As with the hardcoded model, full performance evaluation details of the trained model and some of its components can be found in Chapter~\ref{chapter:evaluation}.


\section{Properties}

As mentioned in Chapter~\ref{chapter:dataset}, property questions in the OceanQA dataset ask the model to find a property value for a specific object. This object, however, can contain a reference to a property value. This means that, in some cases, knowledge of object properties is required in order to find the specified object in the frame. For example, if a question asked ``What colour was the upward-facing fish in frame 12?", and there three fish, each with unique rotations, in frame 12, one would need knowledge of object properties in order to select the correct image of the fish. This means the training data cannot be collated in the same way as the hardcoded model; the model needs a trained property extractor in order to find the images to train the property extractor with.

% This creates a `chicken-and-egg' problem when collecting the training data

In this section we propose a solution to overcome this problem which utilises semi-supervised learning in order to label all of the objects in the dataset with property values. Once these labels have been found, the property component can be trained in the same way as the hardcoded model, outlined in Chapter~\ref{chapter:hardcoded}.

The first step of the algorithm for finding these labels involves training an autoencoder neural network to extract a 16-dimensional latent vector from each object image. This network is trained in an unsupervised manner using a sample of 40,000 of the objects detected by the object detector in the training data, where each object type is equally represented in the sample. The architecture of the network is shown in Figure~\ref{fig:ae-arch}. Each object image is resized to 16$\mathsf{x}$16 pixels and the network is trained with a learning rate of $0.001$ for 5 epochs with a mean-absolute error (MAE) loss function.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{ae-arch}
  \caption{An illustration of the autoencoder architecture. Although not shown here, the network contains batch normalisation layers between each pair of convolution layers. FM stands for feature maps, and the dimensions of each feature maps are given as $(\textit{height}, \textit{width}, \textit{number of feature maps})$.}
  \label{fig:ae-arch}
\end{figure}

The autoencoder allows the component to work with the latent vectors of objects rather than raw object images. At this stage, every object in the training data is encoded using the autoencoder and stored in vector form. After the autoencoder has been trained and all the objects have been encoded, the properties component splits objects in groups based on their class. The component then proceeds to individually apply the following three high-level steps, which are described in further detail in the sections below, to each object type, $t_i$:
\begin{enumerate}
  \item The objects with type $t_i$ are clustered using their latent encoding and each cluster is assigned an integer identifier, $c_j$. More detail on the clustering is outlined in Section~\ref{subsection:trained-clustering}.
  \item The QA pairs will label a number of the objects in the training data with some or all of their property values. ASP can be used to find a mapping from each $c_j$ to a set of property-value pairs. The ASP program used to conduct this mapping is described in Section~\ref{subsection:trained-mapping-optimisaton}.
  \item Once this mapping is known, all of the objects of type $t_i$ in the training data can be labelled. The algorithm for finding these labels is outlined in Section~\ref{subsection:trained-data-labelling}.
\end{enumerate}

As mentioned above, when the property value labels have been found for all objects of all types, the property component can be trained using the same method as the hardcoded model, discussed in Chapter~\ref{chapter:hardcoded}.


\subsection{Clustering}
\label{subsection:trained-clustering}

An analysis of the full-data version of the OceanQA dataset (where objects come fully labelled with their properties) shows that the information encoded in the latent vector of each object separates objects into distinct groups based on their properties. This makes clustering a strong candidate for explicitly separating the objects into distinct groups. The Principle Component Analysis (PCA) projection of the latent vectors for octopus and fish into 2-dimensions is shown in Figure~\ref{fig:latents}.

Clustering of the object latent vectors is done using the \textit{Agglomerative Clustering} algorithm implemented by the \textit{SciKitLearn}\footnote{Available at https://scikit-learn.org/stable/modules/clustering.html} library. While many other clustering algorithms are available, Agglomerative Clustering was found to work efficiently with a large number of samples. Unlike some other clustering algorithms, however, Agglomerative Clustering requires that the number of clusters to be produced is known beforehand.

\begin{figure}[t]
  \begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{octopus-latents-rotation.png}
    \caption{Latent space of octopus rotations.}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.48\textwidth}
    \centering
    \includegraphics[width=\textwidth]{fish-latents-rotation.png}
    \caption{Latent space of fish rotations.}
  \end{subfigure}
  \caption{2-dimensional representation of the latent space of octopus and fish images. The colours show different rotation values. Note, these property values come from the full-data version of the OceanQA dataset, not from clustering. Although not shown here, rocks and bags follow a very similar pattern to fish.}
  \label{fig:latents}
\end{figure}

\begin{table}[h!]
  \centering
  \begin{tabular}{ |c|c c c| }
    \hline
    \textbf{Object Type} & \textbf{\#Colours} & \textbf{\#Rotations} & \textbf{\#Clusters} \\
    \hline
    Octopus & 5 & 4 & 20 \\
    Fish    & 1 & 4 & 4 \\
    Bag     & 1 & 4 & 4 \\
    Rock    & 4 & 1 & 4 \\
    \hline
  \end{tabular}
  \caption{Estimates of the number of clusters required for each class, calculated by multiplying the number of colour and rotation values found in the property questions.}
  \label{table:property-combinations}
\end{table}

In order to calculate the number of clusters required for each class, we analyse the number of property values that are linked with that class in the QA pairs. For example, fish only take a single colour, silver, and so only this colour will be mentioned in the property questions that ask about fish. Additionally, fish can take four rotations, and so we expect that all four of these rotations will be mentioned in the questions. In total this gives us four possible property value combinations for fish. We repeat this process for all four object types and list the results in Table~\ref{table:property-combinations}.

In theory, it is possible that this method of calculating the number of clusters required may underestimate, since not all property values may be mentioned in the QA pairs. In practice, however, this makes little difference because if a particular property value is not represented in the QA pairs it is likely to be very rare in the videos and in the evaluation questions.

\begin{figure}
  \centering
  \includegraphics[width=0.75\textwidth]{octopus-clusters.png}
  \caption{Output of the Agglomerative Clustering algorithm for the octopus images.}
  \label{fig:octopus-clusters}
\end{figure}

Figure~\ref{octopus-clusters} shows the result of the clustering algorithm applied to the octopus images, projected into two dimensions. After clustering has been completed for a given class, we assign each cluster (each different colour shown in Figure~\ref{fig:octopus-clusters}) an integer identifier. The data collection problem outlined at the start of this chapter has now been reduced to finding the mapping from each cluster identifier to a set of property-value pairs, which optimises some objective function, for each object type $t_i$. For example, for a cluster $c_j$, we want to find the optimal values for colour and rotation which correspond to $c_j$. We denote the optimal mapping from the set of cluster identifiers $C$ to the set of sets of property-value pairs $P$, for object type $t_i$ as $f_{t_i}^*: C \rightarrow P$.


\subsection{Property Value Optimisation}
\label{subsection:trained-mapping-optimisaton}

In order to find $f_{t_i}^*$, we must first define the objective function. Since we have a set of property questions and answers, we choose to maximise the number of questions answered correctly. It is now necessary to find the questions which correspond to object type $t_i$. We also use the question and answer parsing component (outlined in Chapter~\ref{chapter:h-perl}) to extract the relevant symbolic information from the question and from the answer. We denote the information extracted from QA pair $k$ as $(p_k, v_k, a_k)$, where $p_k$ is the property mentioned in the question (or $Null$ if there isn't one), $v_k$ is an optional property value mentioned in the question and $a_k$ is the answer, which is a property value.

ASP is then used to conduct the optimisation. One ASP program is constructed for each object type. We outline the ASP program for the object type $t_i$ in the following five stages:
\begin{enumerate}
  \item Firstly, the search space for the optimisation is constructed using choice rules. For each cluster identifier $c_j$, the following two choice rules are added:
  \begin{gather}
    1\{ colour\_mapping(c_j, col_1) ; ... ; colour\_mapping(c_j, col_n) \}1. \\
    1\{ rotation\_mapping(c_j, rot_1) ; ... ; rotation\_mapping(c_j, rot_m) \}1.
  \end{gather}
  \textit{Where the set of possible colour values is: $\{col_1,...,col_n\}$ and the set of possible rotation values is: $\{rot_1,...,rot_m\}$.}

  These choice rules generate one answer set for each possible combination of property-value pairs. Notice that no attempt has been made to restrict the property-value pairs to those which were used to select the number of clusters, since the ASP optimisation will naturally choose the property-value pairs which answer the most questions correctly.

  \item Secondly, for each QA pair, the object data from the frame given in the question is added to the program. Only the objects with type $t_i$ are added. For example, if a question says ``What colour was the leftward-facing fish in frame 23?" and three fish have been detected in frame 23, then only the information for those three fish are listed in the program (fish from other questions will of course be listed in the same program).

  Each of the objects to be added will be given an integer identifier, this identifier is unrelated to the identifier assigned by the tracking component. Each object is also listed with the cluster identifier that it was assigned to. For each object listed in QA pair \textit{$<$k$>$}, which is part of cluster $c_i$ and has identifier $id$, the following predicate is added to the ASP program:
  \begin{equation}
    obj(id, c_i, \textit{$<$k$>$}).
  \end{equation}

  \item A number of helper ASP rules which convert object data in the form of the $obj$ and $\textit{$<$prop$>$}\_mapping$ predicates into the $holds$ predicate, which is used to answer the questions. These two helper rules are as follows:
  \begin{gather}
    holds(colour(\mathit{Val}, \mathit{Id}), Q) :- \begin{multlined}[t]
      obj(\mathit{Id}, Cluster, Q), \\
      colour\_mapping(Cluster, \mathit{Val}).
    \end{multlined} \label{rule:holds-colour} \\
    holds(rotation(\mathit{Val}, \mathit{Id}), Q) :- \begin{multlined}[t]
      obj(\mathit{Id}, Cluster, Q), \\
      rotation\_mapping(Cluster, \mathit{Val}).
    \end{multlined} \label{rule:holds-rotation}
  \end{gather}

  Rules~\ref{rule:holds-colour} and~\ref{rule:holds-rotation} collate the data from the object's cluster and from the property value that that cluster has been assigned and convert this data into $holds$ form. The $holds$ predicate can then be used to answer the questions.

  \item Next, the ASP rules corresponding to the questions and the ASP facts corresponding to the answers to those questions are added to the program. We firstly find the tuples $(p_k, v_k, a_k)$ which correspond to the object type $t_i$ are extracted by the question and answer parsing component from the $\textit{$<$k$>$}^{th}$ QA pair. The following rule and fact are then added if $v_k$ is not $Null$:
  \begin{gather}
    answer(\textit{$<$k$>$}, p_k, V) \text{ :- } \begin{multlined}[t]
      holds(p_{v_k}(v_k, \mathit{Id}), \textit{$<$k$>$}), \\
      holds(p_k(V, \mathit{Id}), \textit{$<$k$>$}), obj(\mathit{Id}, \_, \textit{$<$k$>$}).
    \end{multlined} \\
    answer(\textit{$<$k$>$}, p_{v_k}, V) \text{ :- } \begin{multlined}[t]
      holds(p_{v_k}(V, \mathit{Id}), \textit{$<$k$>$}), \\
      holds(p_k(v_k, \mathit{Id}), \textit{$<$k$>$}), obj(\mathit{Id}, \_, \textit{$<$k$>$}).
    \end{multlined} \\
    expected(\textit{$<$k$>$}, p_k, a_k). \\
    expected(\textit{$<$k$>$}, p_{v_k}, v_k).
  \end{gather}
  \textit{Where $p_{v_k}$ is the property which corresponds to property value $v_k$.}

  For example, the question ``What colour is the downward-facing bag in frame 7?" and answer ``white", would be converted into the following:
  \begin{gather}
    answer(\textit{$<$k$>$}, colour, V) \text{ :- } \begin{multlined}[t]
      holds(rotation(down, \mathit{Id}), \textit{$<$k$>$}), \\
      holds(colour(V, \mathit{Id}), \textit{$<$k$>$}), obj(\mathit{Id}, \_, \textit{$<$k$>$}).
    \end{multlined} \\
    answer(\textit{$<$k$>$}, rotation, V) \text{ :- } \begin{multlined}[t]
      holds(rotation(V, \mathit{Id}), \textit{$<$k$>$}), \\
      holds(colour(white, \mathit{Id}), \textit{$<$k$>$}), obj(\mathit{Id}, \_, \textit{$<$k$>$}).
    \end{multlined} \\
    expected(\textit{$<$k$>$}, colour, white). \\
    expected(\textit{$<$k$>$}, rotation, down).
  \end{gather}

  Two rules are created for questions where $v_k$ is not $Null$ because the question gives away two pieces of information: the colour and the rotation. However, when $v_k$ is $Null$, the following ASP rule and fact are used instead:
  \begin{gather}
    answer(\textit{$<$k$>$}, p_k, V) \text{ :- } holds(p_k(V, \mathit{Id}), \textit{$<$k$>$}), obj(\mathit{Id}, \_, \textit{$<$k$>$}). \\
    expected(\textit{$<$k$>$}, p_k, a_k).
  \end{gather}

  \item The final part of the ASP program is the set of weak constraints used to find the optimal mapping. We firstly define the helper rule, $mapping$, which is used to collate both the colour and rotation property values for each cluster:
  \begin{equation}
    mapping(\mathit{C}, \mathit{Col}, \mathit{Rot}) \text{ :- } \begin{multlined}[t]
      colour\_mapping(\mathit{C}, \mathit{Col}), \\
      rotation\_mapping(\mathit{C}, \mathit{Rot}).
    \end{multlined}
  \end{equation}

  The weak constraints are then defined as follows:
  \begin{gather}
    \text{:$\sim$ } answer(Q, \mathit{Prop}, \mathit{Val}), expected(Q, \mathit{Prop}, \mathit{Val}). [-1@2, Q, \mathit{Prop}, \mathit{Val}] \label{rule:answer-constraint} \\
    \text{:$\sim$ } \begin{multlined}[t]
      mapping(\mathit{C1}, \mathit{Col}, \mathit{Rot}), mapping(\mathit{C2}, \mathit{Col}, \mathit{Rot}), \\
      \mathit{C1} \text{ != } \mathit{C2}. [1@1, \mathit{C1}, \mathit{C2}, \mathit{Col}, \mathit{Rot}]
    \end{multlined} \label{rule:mapping-constraint}
  \end{gather}

  The body of Rule~\ref{rule:answer-constraint} is satisfied when question $Q$ is answered correctly. Since we are looking to maximise the number of questions answered correctly and ASP always minimises weak constraints, we give this rule a negative weight. This rule is given the higher priority of the two.

  Rule~\ref{rule:mapping-constraint}, on the other hand, says that we prefer answer sets where mappings are unique. This rule could also be used as a hard constraint to rule out any answer sets where the mappings are not unique. However, we choose not to enforce this constraint so that the ASP optimiser could choose an answer set where more questions are answered correctly, at the expense of non-unique mappings. The reason for this decision is the following:
  \begin{displayquote}
    If a group of objects with the same property values is split between two or more clusters, and these objects are commonly asked about in the QA pairs, then the ASP optimiser has the ability to assign multiple object clusters to the same property values, if it leads to a larger number of questions being answered correctly.
  \end{displayquote}
  We therefore always try to ensure whatever rules the model learns it learns them in order to maximise the number of questions answered correctly. Hence, Rule~\ref{rule:answer-constraint} is given the highest priority.
\end{enumerate}

The ASP program is run for each object type $t_i$, and $\textit{$<$prop$>$}_mapping$ predicates contained in the optimal answer set in each case are then used to find the optimal mapping $f_{t_i}^*$, which is then stored and used to label all objects in the training data.


\subsection{Data Labelling}
\label{subsection:trained-data-labelling}

Once $f_{t_i}^*$ has been found for every object type $t_i$, all of the objects in the training data can be labelled with property values. Labelling an object's property values requires that the centre point of each cluster be computed. For the sake of efficiency, the cluster centres are precomputed for each object type. The centre for a cluster $c_j$ is computed as the average of the object latent vectors assigned to $c_j$.

After clusters centres have been computed, we assign property values to an object $obj_k$ with type $t_i$ as follows:
\begin{enumerate}
  \item The object's image is encoded into a latent vector, $v_k$, using the autoencoder.
  \item For each cluster $c_j$ which corresponds to object type $t_i$, we compute the cosine distance between $v$ and the centre of $c_j$. The object is assigned to the cluster with the smallest distance, which we denote $c^*$.
  \item Using the mapping found by the ASP optimisation for object type $t_i$, we can simply look up the optimal set of property values that correspond to $c^*$.
\end{enumerate}

Using this method, property values can be assigned to all detected objects in the training videos using only each object's image. After property values have been assigned, we train the property component in exactly the same way as Chapter~\ref{chapter:hardcoded}.

Although the method for training the property component outlined in this section works well when objects are simple and uniform, it is unlikely to scale to more complex, \textit{real-world} datasets. This is because, when training an autoencoder in an unsupervised way, it can learn to extract a lot of noise from the images. When the latent vectors of object images are noisy, clustering will not be as successful in splitting the objects into groups based on their property values.

The speed of the optimisation may also be a concern if the number of property values is large, since the size of the search space scales exponentionally with the average number of property values. However, for the purposes of the OceanQA dataset neither of these potential drawbacks causes any problems. The details of the evaluation of the trained property component, along with the entire trained model, is available in Chapter~\ref{chapter:evaluation}.


\section{Relations}

Unlike the relations component in the hardcoded model, which used a manually engineered algorithm, the relations component in the trained model must learn definitions of binary relations between objects from data. As with the trained properties component outlined above, the relations component uses the QA-data version of the OceanQA dataset. Before the relations component is trained, the trained properties component is used to label all of the objects in the training data with property values.

Instead of using manually engineered functions, we opt to use a neural network consisting of fully-connected layers as the core implementation of the relations component. For a generic environment, one neural network would be created for each binary relation, however, since OceanQA only has one relation, only one network is required for this component.
Each of these networks is assigned a binary relation, $r$, to learn. Each network therefore takes a pair of objects as input, and learns to classify the objects as either being related by $r$ or not.

Since fully-connected layers work with numbers, rather than symbolic data, we need to find a way to encode a pair of objects into a vector. To do this we encode each object in the pair separately (an example encoding of an object is shown in Figure~\ref{fig:encoding}) and then concatenate the two encodings together. The encoding of an object is the result of concatentating each of the following:
\begin{enumerate}
  \item A one-hot encoding of the object's type.
  \item A one-hot encoding of object's colour.
  \item A one-hot encoding of object's rotation.
  \item The position tuple for the object, where each coordinate has been divided by 256 to produce a number of between $0$ and $1$.
\end{enumerate}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{encoding}
  \caption{The vector encoding for a blue, downward-facing octopus, roughly in position $(54, 187, 70, 203)$. In the component itself the position is given to a much higher degree of accuracy than shown here.}
  \label{fig:encoding}
\end{figure}

The neural network takes the vector encoding of the pair of objects as input and passes this vector through a series of fully-connected layers. The details of the layers are shown in Table~\ref{table:relations-network}. As shown in the table, the output of the network is a single neuron. The sigmoid function is applied to the output of the network to ensure the value is between $0$ and $1$. If the value of the output of a network learning relation $r$ is denoted $o_r$, then the relation classifier component's output for a pair of objects, denoted $r(\mathit{obj1}, \mathit{obj2})$, is as follows:
\begin{equation}
  r(\mathit{obj1}, \mathit{obj2}) =
  \left\{
  	\begin{array}{ll}
  		true  & \mbox{if } o_r \geq 0.5 \\
  		false & \mbox{otherwise}
  	\end{array}
  \right.
  \label{eqn:trained-close-def}
\end{equation}

\begin{table}[b]
  \centering
  \begin{tabular}{ |c|c c| }
    \hline
    \textbf{Layer} & \textbf{Input Size} & \textbf{Output Size} \\
    \hline
    Fully-connected 1 & 38   & 1024 \\
    Fully-connected 2 & 1024 & 256  \\
    Fully-connected 3 & 256  & 64   \\
    Fully-connected 4 & 64   & 1    \\
    \hline
  \end{tabular}
  \caption{Details of the layers of each relation classification network. The input is the size of two encoded objects, and the output is used for binary classification. Dropout of $0.2$ is also applied between each pair of layers.}
  \label{table:relations-network}
\end{table}

Since the OceanQA dataset has only a single binary relation, \textit{close}, only one neural network is required to be trained for the relation component. Training this network is fairly straightforward; the process is comprised of the following steps:
\begin{enumerate}
  \item All of the relation questions in the QA-data version of the training dataset are collated.
  \item From each QA pair, a frame number, two objects (including types and, optionally, property values) and the answer are extracted using the question-and-answer parsing component.
  \item The frame number and object information is used to look up any missing property values for each object. The property component has already been applied to the dataset, so the property values of all detected objects are guaranteed to be labelled. The full set of property values, as well as the object type and position from the detector, is used to construct the object encoding. The two encodings are concatenated to produce the object-pair encoding.
  \item Finally, the set of object-pair encodings, and their associated answers, is used to train the network corresponding to the \textit{close} relation.
\end{enumerate}

After the network has been trained, the component can be used to classifier binary relations between objects. When being applied to a given video, the relations component classifies every pair of objects in every frame of the video as being either close or not using Equation~\ref{eqn:trained-close-def}. If two objects in frame $\textit{$<$frame$>$}$ with identifiers \textit{$<$id1$>$} and \textit{$<$id2$>$}, respectively, are deemed to be close by the component, then the $obs(close(\textit{$<$id1$>$}, \textit{$<$id2$>$}), \textit{$<$frame$>$})$ predicate is stored. For any pair of objects deemed to not be close, nothing is stored; the closed-world assumption (CWA) - that is, that any predicate which cannot be proved to be true is false - is made for relations between objects.

Applying the network to every pair of objects in every frame of a video could become a burden on the speed of the relations component, especially when there are many objects in each frame. Batching pairs of objects together when applying them to the network helps to improve efficiency, but it has its limits. Chapter~\ref{chapter:evaluation} shows that the relations component is the second slowest, after the detector, of all the components in the trained model. However, for the purposes of this project, the relations component is fast enough. Chapter~\ref{chapter:evaluation} also shows the full details of this components performance with perfect inputs.


\section{Events}

The final of the three core components in the trained model is the event component. As with the properties and relations component, the event component uses the QA-data version of the dataset for training. However, unlike the previous components, both the properties and relations components are applied to the training data in order to extract relevant symbolic information, prior to training the event component. During training, the event component can therefore access data that has been extracted by all preceeding components in the architecture: the object detector, properties, tracking and relations components.

\pagebreak

Since a lot of symbolic information will already have been extracted from the video during evaluation by preceeding components, the event component does not need to look at raw pixels in the video at all. Instead, it is much more efficient to use the data that has already been gleaned from the video to work out which events occur. Unlike the hardcoded events component, the trained component cannot assume to have access to an $\mathcal{AL}$ model of the environment. Instead, it must learn its own symbolic rules using the training data. One option is to learn an $\mathcal{AL}$ model and use this to find which events occur in the same way as the hardcoded component. However, these $\mathcal{AL}$ rules can be quite complex, so we do not consider this option for this project. Instead, we opt to learn ASP rules which, given a symbolic enoding for a pair of frames, return the action which occurs between the two frames. Once the actions for the entire video have been found, additional ASP rules can be used to find the effects.


\subsection{Terminology}

The ASP rules for finding the actions which occur in a video are found using a greedy search algorithm. The algorithm is run three times; once for each each action. Before outlining this algorithm, we define the terminology used as follows:
\begin{itemize}
  \item \textbf{Feature} :- High-level names, whose values categorise the state of an object. We make use of the following features: $x$-position, $y$-position, colour, rotation and disappear (defined below). Each object has a specific value for each feature, which come (directly or indirectly) from the information extracted from the video.

  \item \textbf{Feature Sort} :- Each feature can be categorised into the following three \textit{sorts}, based on the set of possible values that an object can hold for that feature:
  \begin{enumerate}
    \item \textbf{Binary}. Disappear is the only binary feature.
    \item \textbf{Discrete} (excluding binary). Colour and rotation are discrete features.
    \item \textbf{Continuous}. $x$-position and $y$-position are both continuous features.
  \end{enumerate}

  \item \textbf{Feature Operation} :- An operation that is applied to the value of a feature. Each feature operation is usually intended to be applied to a single feature \textit{sort}. For example, a discrete feature operation cannot be applied to continuous feature values.

  \item \textbf{Operation Result} :- The result of applying a feature operation to a feature value. Every operation result must be a binary value, since we want to use these values in the body of ASP rules.
\end{itemize}

The goal of the training algorithm is, given a dataset $\{(F_i, F_{i+1}, a_i)\}$, where $F_i$ and $F_{i+1}$ is the set of feature values for frame $i$ and $i+1$, respectively, and $a_i$ is the action which occurs between frame $i$ and $i+1$, find a set of rules with feature operations in the body which best explain the data. In this case, explaining the data means maximising the number of questions answered correctly, where each QA pair contains a frame $i$ (using which we can look up $F_i$ and $F_{i+1}$ in the extracted data) and an answer (which provides $a_i$).

As mentioned above, each feature operation is associated with a feature sort. For each sort, we now define the set of possible operations that can be applied to feature values of that sort. For every object in the video, a feature operation $\sigma$ is applied to the pair $(f_{v_{i}}, f_{v_{i+1}})$, where $f_{v_i}$ and $f_{v_{i+1}}$ are the object's values for feature $f$ in frame $i$ and $i+1$, respectively. Every set of feature operations also includes the $\top$ operation, which always evaluates to true.

Firstly, for binary features we only consider values in the initial frame, however, it would be very simple to expand this to include both frames. In the following, we show the the set of possible feature operations for a binary feature, $\Sigma_{\mathit{binary}}$. Each operation takes the pair $(f_{v_{i}}, f_{v_{i+1}})$ as input:
\begin{equation}
  \Sigma_{\mathit{binary}} =
  \left\{
  	\begin{array}{ll}
  		\sigma(f_{v_{i}}, f_{v_{i+1}}) := f_{v_i} \\
  		\sigma(f_{v_{i}}, f_{v_{i+1}}) := \neg f_{v_i} \\
      \sigma(f_{v_{i}}, f_{v_{i+1}}) := \top
  	\end{array}
  \right\}
  \label{eqn:binary-ops}
\end{equation}

Secondly, a pair of discrete feature values $(f_{v_{i}}, f_{v_{i+1}})$ can have the following feature operations applied:
\begin{equation}
  \Sigma_{\mathit{discrete}} =
  \left\{
  	\begin{array}{ll}
  		\sigma(f_{v_{i}}, f_{v_{i+1}}) := f_{v_i} = v_n, f_{v_{i+1}} = v_m \textit{ for each $(v_n, v_m)$} \\
  		\sigma(f_{v_{i}}, f_{v_{i+1}}) := f_{v_i} = f_{v_{i+1}} \\
      \sigma(f_{v_{i}}, f_{v_{i+1}}) := f_{v_i} != f_{v_{i+1}} \\
      \sigma(f_{v_{i}}, f_{v_{i+1}}) := \top
  	\end{array}
  \right\}
  \label{eqn:discrete-ops}
\end{equation}
\textit{Where $(v_n, v_m)$ loops over all possible combinations of feature values.}

Finally, a pair of continuous feature values $(f_{v_{i}}, f_{v_{i+1}})$ can take the following feature operations:
\begin{equation}
  \Sigma_{\mathit{continuous}} =
  \left\{
  	\begin{array}{ll}
  		\sigma(f_{v_{i}}, f_{v_{i+1}}) := f_{v_i} > f_{v_{i+1}} \\
      \sigma(f_{v_{i}}, f_{v_{i+1}}) := f_{v_i} < f_{v_{i+1}} \\
  		\sigma(f_{v_{i}}, f_{v_{i+1}}) := f_{v_i} = f_{v_{i+1}} \\
      \sigma(f_{v_{i}}, f_{v_{i+1}}) := f_{v_i} != f_{v_{i+1}} \\
      \sigma(f_{v_{i}}, f_{v_{i+1}}) := \top
  	\end{array}
  \right\}
  \label{eqn:continuous-ops}
\end{equation}

The $\top$ feature operations always gives an operation result of \textit{true}. Intuitively, a $\top$ feature operation has no effect on the outcome of the rule it is in. Since the algorithm has the option to choose the $\top$ feature operation for any feature, we can enforce that all features appear in every rule body at least once. Any feature that the algorithm doesn't care about can be assigned a $\top$ feature operation. For simplicity, we also enforce that each feature can appear at most once in a rule body. The search algorithm therefore tries to learn a set of rules, where each rule takes the following form:
\begin{equation}
  a_i \textbf{ if } \begin{multlined}[t]
    \sigma_{x\_position}(f_{v_{i}}, f_{v_{i+1}}), \sigma_{y\_position}(f_{v_{i}}, f_{v_{i+1}}), \sigma_{colour}(f_{v_{i}}, f_{v_{i+1}}), \\
    \sigma_{rotation}(f_{v_{i}}, f_{v_{i+1}}), \sigma_{disappear}(f_{v_{i}}, f_{v_{i+1}})
  \end{multlined}
  \label{eqn:event-rule-layout}
\end{equation}
\textit{Where each $\sigma_{\textit{$<$f$>$}}$ is a member of \textit{$<$f$>$}'s set of possible feature operations.}

\pagebreak

Each feature operation is also assigned a \textit{weight}. The weight of a rule is then defined as the sum of the weights of its operations. Secondary goals for the optimisation algorithm are, firstly, to minimise the number of rules and, secondly, to minimise the sum of the weights of the rules. In the case of the above feature operations, all operations other than $\top$ are assigned a weight of 1, and $\top$ is assigned a weight of 0. This encourages the optimiser to use $\top$ as much as possible, as long as the set of rules continue to perform well.

Before outlining an Inductive Logic Programming (ILP) search algorithm for finding a set of rules, we first give an example which explains the terminology.

\textbf{Example.} Consider an element of the dataset which includes an action, \textit{move}, and an octopus which is upward-facing, blue and has position $(100, 40, 116, 56)$ in frame 6, and is upward-facing, purple and has position $(100, 25, 116, 41)$ in frame 7. For simplicity we only consider the $x$-position and $y$-position features. Each position feature only uses the top left corner of the object's bounding box, since both corners move by the same amount. The position feature operations are given as follows:

\bigskip

\begin{minipage}{0.45\textwidth}
  \centering
  $x$-position operation $\rightarrow$ result
  \begin{gather*}
    100 > 100 \rightarrow \mathit{false} \\
    100 < 100 \rightarrow \mathit{false} \\
    100 = 100 \rightarrow \mathit{true} \\
    100 \text{ } != 100 \rightarrow \mathit{false} \\
    \top \rightarrow \mathit{true}
  \end{gather*}
\end{minipage}
\begin{minipage}{0.45\textwidth}
  \centering
  $y$-position operation $\rightarrow$ result
  \begin{gather*}
    40 > 25 \rightarrow \mathit{true} \\
    40 < 25 \rightarrow \mathit{false} \\
    40 = 25 \rightarrow \mathit{false} \\
    40 \text{ } != 25 \rightarrow \mathit{true} \\
    \top \rightarrow \mathit{true}
  \end{gather*}
\end{minipage}

\medskip

Clearly, given only this single example, there are many possible rules which the algorithm could learn, many of which will be undesirable. However, when there are a more significant number of examples, the algorithm should be able to learn rules which correctly model the environment.


\subsection{Search Strategy}

Equation~\ref{eqn:event-rule-layout} shows that, for each rule, the training algorithm needs to search over the set of all possible combinations of feature operations, where each feature is assigned exactly one operation in the rule body. Even for a relatively simple environment, such as OceanQA, this is a very large search space, and when the possibility of searching over an arbitrary number of rules is taken into account the space becomes even larger. The number of feature operations for each feature and the total search space size for a complete algorithm which learns only a single rule is shown in Table~\ref{table:feature-op-sizes}.

\begin{table}
  \centering
  \begin{tabular}{ |c|c| }
    \hline
    \textbf{Feature} & \textbf{Search Size} \\
    \hline
    $x$-position & 5 \\
    $y$-position & 5 \\
    colour       & 52 \\
    rotation     & 19 \\
    disappear    & 3 \\
    \hline
    \hline
    Total & 74100 \\
    \hline
  \end{tabular}
  \caption{Number of feature operations for each feature. The total search size is then calculated by multiplying all these sizes together.}
  \label{table:feature-op-sizes}
\end{table}

To ensure the training algorithm remains tractable, we implement a greedy search over features, rather than a complete search over the entire space. Our search algorithm takes each feature individually and finds the operation for the given feature which maximises the number of action questions answered correctly. After each optimisation, we store the set of operations which have been selected as the \textit{accumulated operations}. When the next feature is optimised, each rule in the new hyposthesis can choose to use either the full set of stored operations or none - using none means setting all previously optimised feature operations to $\top$.

Algorithm~\ref{algo:optimise} gives a high-level overview of the steps required to find the optimal hyposthesis - the set of rules which correctly answers the most questions - for every action. Algorithm~\ref{algo:optimise} makes use of the \textsc{OptimiseFeature} function, which takes as input: an action, a set of feature operations, the accumulated feature operations and the training data. This function searches over all of the feature operations to find the set of rules which maximise the number of questions answered correctly. It also searches over the number of rules to be used, as well as whether each of those rules should use an accumulated operation set or not. We implement this function using an ASP optimisation program, the encoding for which is outlined in Section~\ref{subsection:trained-events-asp-enc}.

\begin{algorithm}[bp!]
  \caption{Finding the optimal hyposthesis for each action}
  \label{algo:optimise}
  \begin{algorithmic}[1]
    \Procedure{OptimiseRules}{$\mathit{actions}, \mathit{features}, data$}
      \State $hyps \gets \{\}$
      \For{$a \gets actions$}
        \State $acc \gets \{\}$
        \For{$f \gets \mathit{features}$}
          \State $s \gets$ \Call{SortOf}{$f$}
          \State $acc \gets $ \Call{OptimiseFeature}{$action, \Sigma_s, acc, data$}
        \EndFor
        \State $hyp \gets $ \Call{GenHyp}{$a, acc$}
        \State $hyps \gets hyps + (a, hyp)$
      \EndFor
      \State \textbf{return} $hyps$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

In the remainder of this section we provide an inductive description for the task which the \textsc{OptimiseFeature} function must solve.

\pagebreak

Consider an optimisation which uses features $f_1,...,f_{feat}$, and that the algorithm is currently optimising feature $f_i$. The algorithm will therefore be given: an action $a$; the set of feature operations $\Sigma_s$, where $s$ is the sort of $f_i$; the \textit{accumulated operations} $acc_1,...,acc_m$ from the previous feature optimisation, where each $acc_j$ is the set of feature operations used by rule $r_j$ in the previous optimisation; and the training data $D$. In the case where $i=1$, the \textit{accumulated operations} contains a single rule whose feature operations are all set to $\top$. The search space for feature optimisation $f_i$ can then be constructed as follows:
\begin{enumerate}
  \item At the highest level of the search, the algorithm needs to choose how many rules to learn. Therefore we start by creating one node in the search tree for each possible number of rules in $\{ 1, 2, ..., R_{max} \}$, where $R_{max}$ is a hyperparameter of the search.

  \item Then, for each possible number of rules, each rule can choose to use at most one of $\{ acc_1,...,acc_m \}$. Therefore, for each previous node $n$, which allows $R$ rules, each rule in $\{ r_1,...,r_R \}$ chooses between $m$ accumulators or none, meaning $(m+1)^R$ child nodes must be added to $n$, since $(m+1)^R$ is the number of possible combinations of accumulator choices. This part of the search tree is shown in Figure~\ref{fig:acc-search} for the node where $R=2$ and two accumulators are carried over.

  \item Finally, after choosing which accumulator to use (or none), each rule chooses a feature operation for the feature $f_i$. This means, for each leaf node $n$ constructed so far, we add a child node to $n$ for each possible feature operation $\sigma_i \in \Sigma_{s}$.
\end{enumerate}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{acc-search}
  \caption{Accumulator assignment nodes in the search tree, where the number of rules is two and two accumulators are carried forward.}
  \label{fig:acc-search}
\end{figure}

Once the search space has been constructed, the optimiser evaluates each of the leaf nodes in the tree outlined above, and chooses the node which maximises the number of action questions answered correctly. The \textsc{OptimiseFeature} function then returns accumulated set of feature operations, $\{ acc_1, ..., acc_i \}$, so that they can be used for the next feature optimisation.


\subsection{ASP Encoding}
\label{subsection:trained-events-asp-enc}

This section outlines the details the ASP program which is used in place of the \textsc{OptimiseFeature} function described above. As expected, the program creates the search space using choice rules, and evaluates each possible answer set by counting the number of action questions it answers correctly.

The ASP program for a feature $f$, feature operations $\Sigma = \{ \sigma_1,...,\sigma_n \}$, action $\mathit{action}$, accumulator set $acc_1,...,acc_m$ and dataset $D$ is constructed as follows:
\begin{enumerate}
  \item Firstly, the action-type questions in $D$ (including those which do not mention $action$) are collated, these are denoted $D_a$. From the questions in $D_a$ we extract the frame number $i$ using the question-and-answer parser, and use this frame number to look up the symbolic representation for frame $i$ and $i+1$. We collate these symbolic representations, along with each action, as the tuple $(F_i, F_{i+1}, a)_j$, where $j$ is a unique integer identifier assigned to each tuple in the dataset. We then represent $F_i$ and $F_{i+1}$ in ASP as described in Chapter~\ref{chapter:h-perl}, with the exception that $F_i$ is assigned frame identifier $j$, and $F_{i+1}$ is assigned frame identifier $-j$. This is done so that all frames in the dataset can be added to the same ASP program. The action $\mathit{action}$ for tuple $j$ is then represented as:
  \begin{equation}
    actual(\mathit{action}, j).
  \end{equation}

  \item Secondly, each accumulated feature operation, $acc_i = \{ (\mathit{feat}, \sigma_{id}) \}$, is a set of tuples, where $\mathit{feat}$ is the name of a feature and $\sigma_{id}$ is the identifier assigned to a feature operation (each operation is assigned an integer identifier which is unique within its feature sort). Each element $(\mathit{feat}, \sigma_{id})$ of $acc_i$ is represented using the following predicate:
  \begin{equation}
    acc(\mathit{feat}, \sigma_{id}, i).
  \end{equation}

  \item Rules~\ref{rule:rule-creation} and~\ref{rule:rule-def}, which follow, define the search space for the number of rules and give each rule an identifier, respectively.
  \begin{gather}
    1 \{ max\_rule\_id(0..\textit{$<$max\_rules$>$}-1) \} 1. \label{rule:rule-creation} \\
    rule(0..\mathit{Max}) \text{ :- } max\_rule\_id(\mathit{Max}). \label{rule:rule-def}
  \end{gather}
  \textit{Where \textit{$<$max\_rules$>$} is a hyperparameter of the component, which specifies the maximum number of rules in the search.}

  \item Next, we need to assign each rule one of the accumulated sets of operators or none. This is done using the following helper and choice rules:
  \begin{gather}
    acc\_id(Acc\_id) \text{ :- } acc(\_, \_, Acc\_id). \\
    1 \{ use\_acc(\mathit{Acc\_id}, Rule) : acc\_id(\mathit{Acc\_id}) \text{ } ; \text{ } no\_acc(\mathit{Rule}) \} 1 \text{ :- } rule(\mathit{Rule}).
  \end{gather}

  There are also a number of rules which set the feature operations (using the $operation$ predicate, described below) based on the accumulator, however, these are not shown here. On the first feature optimisation, we also set any feature which is not being optimised to have operation $\top$, which ensures that all features are represented in the accumulator for successive optimisations.

  \item We now need to generate the possible feature operations that feature $f$ can take. We do this using the following ASP choice rule:
  \begin{equation}
    1 \{ operation(f, Op\_id, R) : op\_weight(f, Op\_id, \_) \} 1 \text{ :- } rule(R).
    \label{rule:operation-gen}
  \end{equation}
  Rule~\ref{rule:operation-gen} generates a potential answer set for each operation of $f$. This rule uses the $op\_weight$ predicate, which defines the weight assigned to each operation for a feature, however, here it is simply used to fetch the operation identifier for each operation of $f$.

  \item Next, we add the rules corresponding to feature operations, $\Sigma = \{ \sigma_1,...,\sigma_n \}$, for $f$. Each operation $\sigma_i$ is a function of two symbolic feature values from an object. Encoding this operation in ASP therefore requires additional body predicates which can fetch these symbolic values. For example, one of the operations for the \textit{colour} feature is: $f_i = green, f_{i+1} = brown$, which require the use of the $obs(colour(f_i, \mathit{Id}), I)$ and $obs(colour(f_{i+1}, \mathit{Id}), -I)$ predicates. In the general case, we refer to each of these predicates as $p(f_i, \mathit{Id}, I)$ and $p(f_{i+1}, \mathit{Id}, -I)$, and the symbolic representation of the feature operation as $op(\sigma_i, f_i, f_{i+1})$. We can then construct the ASP rule for an operation $\sigma_i$ from feature $f$ as follows:
  \begin{equation}
    op\_result(f, \mathit{Id}, I, Rule) \text{ :- } \begin{multlined}[t]
      op(\sigma_i, f_i, f_{i+1}), p(f_i, \mathit{Id}, I), \\
      p(f_{i+1}, \mathit{Id}, -I), operation(f, i, Rule).
    \end{multlined}
  \end{equation}

  The $op\_result(f, \mathit{Id}, I, R)$ predicate stores the binary operation result of feature $f$ in rule $R$ for an object with identifier $\mathit{Id}$ in frame $I$. If $op\_result$ is in the answer set, it is storing the result \textit{true}, otherwise, it is storing \textit{false}.

  \item We also need to add the operation weight for each feature operation. To do this we add the following predicate for each operation $\sigma_i$ of feature $f$:
  \begin{equation}
    op\_weight(f, i, \textit{$<$weight$>$}).
  \end{equation}
  \textit{Where \textit{$<$weight$>$} is 0 for the $\top$ operation and 1 otherwise.}

  \item Since it is the only feature which does not come directly from the symbolic information extracted from the video, we must provide a definition for the \textit{disappear} feature. Intuitively, if an object with identifer $\mathit{Id}$ exists in frame $I$, but not in frame $-I$, then $disappear(\mathit{Id}, I)$ is true (as with actions, disappear can be thought of as occurring between one frame and the next; by convention is is assigned to the initial frame).

  The ASP rule for disappear is as follows:
  \begin{equation}
    \begin{split}
      disappear(\mathit{Id}, I) \text{ :- } & obs(class(Class, \mathit{Id}), I), \\
      & not \text{ } obs(class(Class, \mathit{Id}), -I), \\
      & step(-I), step(I).
    \end{split}
  \end{equation}

  \item We are now in a position to add the rule which generates the prediction of the action $\mathit{action}$ from the operation results. This rule is as follows:
  \begin{equation}
    \begin{split}
      predicted(\mathit{action}, Frame) \text{ :- } & non\_static(\mathit{Id}, I), \\
      & op\_result(x\_position, \mathit{Id}, I, Rule), \\
      & op\_result(y\_position, \mathit{Id}, I, Rule), \\
      & op\_result(rotation, \mathit{Id}, I, Rule), \\
      & op\_result(colour, \mathit{Id}, I, Rule), \\
      & op\_result(disappear, \mathit{Id}, I, Rule), \\
      & rule(Rule).
    \end{split}
  \end{equation}
  \textit{Where $non\_static(\mathit{Id}, I)$ is true for the octopus with identifier $\mathit{Id}$ in frame $I$.}

  \item Finally, we can add the following weak constraints to the ASP program, which is learning rules for $\mathit{action}$:
  \begin{gather}
    \text{:$\sim$ } predicted(\mathit{action}, I), actual(\mathit{action}, I). [-1@3, I] \label{rule:tps} \\
    \text{:$\sim$ } actual(A, I), A \text{ } != \mathit{action}, not \text{ } predicted(\mathit{action}, I). [-1@3, I] \label{rule:tns} \\
    \text{:$\sim$ } count\_rules(Cnt). [Cnt@2] \label{rule:rule-count} \\
    \text{:$\sim$ } Sum = \#sum\{ W, R : rule\_weight(W, R), rule(R) \}. [Sum@1] \label{rule:rule-size}
  \end{gather}
  \textit{Where $count\_rules(Cnt)$ is true when $Cnt$ is the number of rules in the answer set, and $rule\_weight(W, R)$ is true when $W$ is the weight of $R$.}

  Rule~\ref{rule:tps} is satisfied when the predicted action matches the actual action (defined by each element of the dataset). This rule is maximising (since the weight is negative) the number of true positives generated by the action rules. On the other hand, Rule~\ref{rule:tns} maximises the number of true negatives, since its body is satisfied if the learnt hypothesis does not predict $\mathit{action}$ and $\mathit{action}$ is not the answer for this element of the dataset.

  Rule~\ref{rule:rule-count} attempts to minimises the number of rules which appear in the learnt hyposthesis, while Rule~\ref{rule:rule-size} attempts to minimise the total weight of the rules in the hypothesis. Both of these rules, however, are given lower priority than the true positive and true negative rules, since we always prefer a more accurate solution, even if it is longer.
\end{enumerate}



\subsection{Effects}

% TODO mention how effects are modelled separately, why it is helpful to use hybrid model - can add background knowledge of env.



\end{document}
